# ⚠ This document is generated automatically by Generative AI. Currently under reviewed. ⚠


# Nijilive INP Binary & JSON Serialization Output Format Structure Description

This document serves as a formal reference defining the overall structure of the INP binary files generated and read by Nijilive, as well as the format structure of the JSON serialization output data contained within them. The purpose and syntax of each section and field are formally specified.

---

## Table of Contents

- [⚠ This document is generated automatically by Generative AI. Currently under reviewed. ⚠](#-this-document-is-generated-automatically-by-generative-ai-currently-under-reviewed-)
- [Nijilive INP Binary \& JSON Serialization Output Format Structure Description](#nijilive-inp-binary--json-serialization-output-format-structure-description)
  - [Table of Contents](#table-of-contents)
- [1. Overall INP Binary Format Structure (Implementation-Based Specification)](#1-overall-inp-binary-format-structure-implementation-based-specification)
  - [1.1 Entire File Layout](#11-entire-file-layout)
  - [1.2 Section Identifiers and Structure](#12-section-identifiers-and-structure)
  - [1.3 JSON Section](#13-json-section)
  - [1.4 Texture Section ("TEX\_SECT")](#14-texture-section-tex_sect)
  - [1.5 Extension Section ("EXT\_SECT")](#15-extension-section-ext_sect)
  - [1.6 Versioning and Extensibility](#16-versioning-and-extensibility)
  - [1.7 Comparison with Spec-Driven "Chunked" Layout](#17-comparison-with-spec-driven-chunked-layout)
  - [2. Top-Level Structure](#2-top-level-structure)
    - [2.1 Puppet Structure (JSON Root)](#21-puppet-structure-json-root)
    - [2.2 Meta Section](#22-meta-section)
    - [2.2 Physics Section](#22-physics-section)
    - [2.3 Nodes Section](#23-nodes-section)
      - [2.3.1 Common Node Specification](#231-common-node-specification)
      - [2.3.2 Details of Each Node Type](#232-details-of-each-node-type)
      - [2.3.3 MeshData.serialize Output Details](#233-meshdataserialize-output-details)
    - [2.4 Param, Automation, Animations Sections](#24-param-automation-animations-sections)
      - [2.4.1 Param Section](#241-param-section)
      - [2.4.2 Automation Section](#242-automation-section)
      - [2.4.3 Animations Section](#243-animations-section)
    - [2.5 Parameter Binding Specification](#25-parameter-binding-specification)
      - [Basic Syntax](#basic-syntax)
      - [Common Output Items](#common-output-items)
      - [2.5.1 DeformationParameterBinding](#251-deformationparameterbinding)
      - [2.5.2 ParameterParameterBinding](#252-parameterparameterbinding)
      - [2.5.3 ValueParameterBinding](#253-valueparameterbinding)
  - [3. Hierarchical Structure and Serializer Invocation](#3-hierarchical-structure-and-serializer-invocation)
  - [4. Overall Output Format Characteristics](#4-overall-output-format-characteristics)
  - [5. Notes on Specification](#5-notes-on-specification)

---

# 1. Overall INP Binary Format Structure (Implementation-Based Specification)

This section formally describes the actual binary layout generated by the provided INP file writing implementation.
It supersedes the generic "chunked header" description with the specific streaming structure used in code.

## 1.1 Entire File Layout

The INP binary file consists of the following ordered segments, written sequentially (streamed). There is no global section table or offset-based chunk header.

    INP file overall structure (pseudo-C struct notation):

    struct INPFile {
        uint8_t  magic[8];          // Fixed "TRNSRTS\0" (8 bytes)
        uint32_t jsonLength;        // JSON section byte length (big-endian)
        uint8_t  jsonData[jsonLength];  // Puppet structure as UTF-8 JSON

        // Texture section (optional, present if there are textures)
        uint8_t  texSectionID[8];   // "TEX_SECT" (8 bytes)
        uint32_t texCount;          // Number of textures (big-endian)
        TextureEntry textureEntries[texCount]; // Repeated for each texture

        // Extension section (optional, present if there is extData)
        uint8_t  extSectionID[8];   // "EXT_SECT" (8 bytes)
        uint32_t extEntryCount;     // Number of extension entries (big-endian)
        ExtEntry extEntries[extEntryCount];   // Repeated for each ext entry
    }

    struct TextureEntry {
        uint32_t dataLength;   // Image byte length (big-endian)
        uint8_t  texType;      // Image type (e.g., IN_TEX_TGA)
        uint8_t  imageData[dataLength]; // Raw image data
    }

    struct ExtEntry {
        uint32_t nameLength;   // Payload name length in bytes (big-endian)
        uint8_t  name[nameLength];    // Payload name (UTF-8)
        uint32_t payloadLength;       // Payload length in bytes (big-endian)
        uint8_t  payload[payloadLength]; // Payload binary data
    }

- **Order:** All sections are written sequentially. Each section is present only if corresponding data exists (textures or extData).
- **No global section header or offsets:** Sections are read in the order they appear.
- **No 4-byte alignment or little-endian:** All integer lengths are written as 4-byte big-endian values.

## 1.2 Section Identifiers and Structure

| Section        | Section ID (bytes)   | Content                   | Present When...              |
|:-------------- |:--------------------|:--------------------------|:-----------------------------|
| JSON           | n/a                 | JSON (length-prefixed)    | Always (main model info)     |
| Texture        | "TEX_SECT" (8 bytes)| Texture images            | If any textures exist        |
| Extension Data | "EXT_SECT" (8 bytes)| Named extension payloads  | If extData[] is non-empty    |

- Section IDs ("TEX_SECT", "EXT_SECT") are always 8 bytes, ASCII, no padding.
- There is no use of "JSON" section header; instead, the JSON is always the first content block, prefixed by its 4-byte big-endian length.

## 1.3 JSON Section

- The first section is the model data as a single UTF-8 JSON blob.
- The length of the JSON (in bytes) is written as a 4-byte big-endian unsigned integer, followed immediately by the raw JSON UTF-8 bytes.
- The JSON format itself (structure, keys, fields) is as detailed in Chapter 2 of this document.

## 1.4 Texture Section ("TEX_SECT")

- If the Puppet contains any textures, the string "TEX_SECT" (8 bytes) is written after the JSON section.
- A 4-byte big-endian unsigned integer indicates the number of texture entries.
- Each texture is written as:
    - 4-byte big-endian unsigned integer: length of the image data in bytes.
    - 1 byte: image type (e.g., IN_TEX_TGA).
    - Image binary data (length as above).

## 1.5 Extension Section ("EXT_SECT")

- If there is any extension data (p.extData not empty), the string "EXT_SECT" (8 bytes) is written after any texture sections.
- A 4-byte big-endian unsigned integer indicates the number of extension entries.
- For each extension entry:
    - 4-byte big-endian unsigned integer: length of the name (in bytes)
    - Name as raw UTF-8 bytes (length as above)
    - 4-byte big-endian unsigned integer: length of the payload (in bytes)
    - Payload as raw binary (length as above)

## 1.6 Versioning and Extensibility

- There is **no explicit version field in the binary file header**. The version is only present inside the JSON meta field ("meta.version").
- All section types and field encodings are identified only by their order and section IDs.
- Unknown section types cannot occur, as only "TEX_SECT" and "EXT_SECT" are used.
- The format can only be extended by appending new section types at the end, using new 8-byte section IDs.

## 1.7 Comparison with Spec-Driven "Chunked" Layout

- This implementation does **not** use a top-level section header table or offset-length pairs.
- Section order is **fixed and implicit** (JSON always first, textures if any, then extensions).
- All lengths are encoded as 4-byte big-endian integers.
- All section IDs (where present) are 8 bytes.

---

## 2. Top-Level Structure

### 2.1 Puppet Structure (JSON Root)

The output JSON data is generated as a single object (Puppet) with the following keys.

```
Puppet ::= {
  "meta"       : Meta,              // Meta information
  "physics"    : Physics,           // Physics settings
  "nodes"      : Node,              // Root node (tree structure including child nodes)
  "param"      : [ Parameter, ... ],// Parameter array
  "automation" : [ Automation, ... ],// Automation array
  "animations" : { ... }            // Animation mapping
}
```

- **meta:** Overall metadata (e.g., name, version, author info, etc.).
- **physics:** Physical parameters (e.g., pixelsPerMeter, gravity).
- **nodes:** Root node (Node object). Tree structure with child nodes.
- **param:** Array of parameters (Parameter[]).
- **automation:** Array of automations (Automation[]).
- **animations:** Animation mapping (Animation[string]).

---

### 2.2 Meta Section

**Purpose:** Provides overall meta information.

**Syntax:**

```
Meta ::= {
  "name"        : String,   // Model name
  "version"     : String,   // Nijilive spec version
  "rigger"      : String,   // Rigger (optional)
  "artist"      : String,   // Artist (optional)
  "rights"      : {         // Rights info (optional)
    "allowedUsers": String,
    "allowViolence": Boolean,
    "allowSexual": Boolean,
    "allowCommercial": Boolean,
    "allowRedistribution": String,
    "allowModification": String,
    "requireAttribution": Boolean
  },
  "copyright"   : String,   // Copyright notice (optional)
  "licenseURL"  : String,   // License URL (optional)
  "contact"     : String,   // Contact info (optional)
  "reference"   : String,   // Reference URL, etc. (optional)
  "thumbnailId" : Number,   // Thumbnail texture ID (optional)
  "preservePixels": Boolean // Preserve pixel boundaries (optional)
}
```

---

### 2.2 Physics Section

**Purpose:** Defines basic parameters for physics simulation.

**Syntax:**

```
Physics ::= {
  "pixelsPerMeter": Number, // Pixels per meter
  "gravity": Number         // Gravity acceleration
}
```

---

### 2.3 Nodes Section

**Purpose:** Definition of drawing objects and structures, and expressing hierarchy.

#### 2.3.1 Common Node Specification

Each node has the following basic properties, adding child nodes or transformation info as needed.

```
Node ::= {
  "uuid"        : Number,                // Node unique identifier
  "name"        : String,                // Node name
  "type"        : String,                // Node type (e.g., "Drawable", "Composite", etc.)
  "enabled"     : Boolean,               // Enabled state
  "zsort"       : Number,                // Draw order
  "transform"   : Transform,             // Local transformation info
  "lockToRoot"  : Boolean,               // Lock to root
  "pinToMesh"   : Boolean,               // Pin to mesh
  [ "children"  : [ Node, ... ] ]        // Array of child nodes (recursive nesting, except TmpNode)
}
```

**Transform Syntax:**

```
Transform ::= {
  "trans" : [ Number, Number, Number ], // Translation vector (vec3)
  "rot"   : [ Number, Number, Number ], // Rotation vector (vec3, Euler angles)
  "scale" : [ Number, Number ]          // Scale vector (vec2)
}
```

#### 2.3.2 Details of Each Node Type

Each node type adds the following unique properties to the common specification.

- **Drawable Node**
  ```
  Drawable ::= Node  where "type" = "Drawable" and then {
    "mesh": MeshDataSerialize,
    [ "weldedLinks": [ WeldingLink, ... ] ] // Optional
  }
  ```
  - Note: The mesh info output by `serializeSelf` follows the format defined in 2.3.3. weldedLinks describe weld info with other Drawables (if present).

**WeldingLink Details:**
```
WeldingLink ::= {
  "targetUUID": Number,         // Weld target Drawable node's uuid
  "indices": [ Number, ... ],   // Array mapping own vertex indices to target's (−1 = unlinked)
  "weight": Number              // Welding weight (0.0–1.0)
}
```

- **Composite Node**
  ```
  Composite ::= Node where "type" = "Composite" and then {
    "blend_mode"      : String,
    "tint"            : Color,
    "screenTint"      : Color,
    "mask_threshold"  : Number,
    "opacity"         : Number,
    "propagate_meshgroup": Boolean,
    [ "masks": [ MaskBinding, ... ] ] // Optional
  }
  ```
  - Note: masks is an array of MaskBinding (if present). tint/screenTint are vec3, mask_threshold is Number, propagate_meshgroup is Boolean.

**MaskBinding Details:**
```
MaskBinding ::= {
  "maskSrcUUID": Number,   // Source Drawable node uuid for mask
  "mode": String           // Mask mode (e.g., "Mask", "DodgeMask", etc.)
}
```

- **DynamicComposite Node**
  ```
  DynamicComposite ::= Part  where "type" = "DynamicComposite" and then {
    "auto_resized": Boolean // Whether mesh is auto-resized
  }
  ```
  - Note: Adds auto_resized (Boolean) to all Part node fields (textures, blend_mode, tint, ...).

- **Part Node**
  ```
  Part ::= Drawable where "type" = "Part" and then {
    "textures": [ Number, ... ],
    "blend_mode": String,
    "tint": Color,
    "screenTint": Color,
    "emissionStrength": Number,
    "masks": [ Mask, ... ],
    "mask_threshold": Number,
    "opacity": Number,
    "textureUUIDs": [ String, ... ],
    "meshData": MeshDataSerialize
  }
  ```
  - Note: Adds Part-specific fields to all Drawable node fields (mesh, weldedLinks, etc.).

- **SimplePhysics Node**
  ```
  SimplePhysics ::= Node where "type" = "SimplePhysics" and then {
    "type"             : String,   // Physics model type (e.g., "Pendulum", "SpringPendulum", etc.)
    "damping"          : Number,   // Damping coefficient
    "restore_constant" : Number,   // Restoration constant
    "gravity"          : Number,   // Gravity acceleration
    "input_scale"      : Number,   // Input scale
    "propagate_scale"  : Number    // Propagation scale
    // Additional parameters may be output for other models such as SpringPendulum
  }
  ```
  - Note: In implementation, type is the name of the physical model (e.g., "Pendulum" or "SpringPendulum"). Additional parameters for SpringPendulum are not output currently.

- **MeshGroup Node**
  ```
  MeshGroup ::= Drawable  where "type" = "MeshGroup" and then {
    "dynamic_deformation": Boolean,
    "translate_children": Boolean
  }
  ```
  - Note: Adds dynamic_deformation and translate_children to all Drawable node fields (mesh, weldedLinks, etc.). The grid field is not output in the current implementation.

- **Deformable Node**
  ```
  Deformable is an abstract class and is never output directly as type: "Deformable". Output is performed by concrete classes such as Part, Mask, MeshGroup, PathDeformer, etc.
  ```

- **PathDeformer Node**
  ```
  PathDeformer ::= Node where "type" = "PathDeformer" and then {
    "physics_only" : Boolean,         // Physics-only flag (optional)
    "curve_type"   : String,          // "Bezier" or "Spline"
    "vertices"     : [ Number, ... ], // Array of x, y coordinates for each vertex, interleaved
    [ "physics"    : {                // Physics driver info (if present)
         "type"             : String,
         "damping"          : Number,
         "restore_constant" : Number,
         "gravity"          : Number,
         "input_scale"      : Number,
         "propagate_scale"  : Number
      } ]
  }
  ```
  - Note: Physics driver info is output with the "physics" key, where type is "Pendulum" or "SpringPendulum". vertices is an [x, y, x, y, ...] array.

- **Mask Node**
  ```
  Mask nodes are output as type: "Mask" Node. They do not have id, mode, or threshold fields; the output content is the same as Drawable nodes, including mesh info.
  ```

- **Puppet Structure**
  ```
  Puppet ::= {
    "meta"       : Meta,
    "physics"    : Physics,
    "nodes"      : [ Node, ... ],
    "param"      : ParamSection,
    "automation" : AutomationSection,
    "animations" : AnimationsSection
  }
  ```
  - Note: All sections are integrated to ensure overall output consistency.

#### 2.3.3 MeshData.serialize Output Details

The result of MeshData.serialize is output as a JSON object in the following format:

```
MeshDataSerialize ::= "{" 
    "\"verts\""     ":" NumberList
    [ "," "\"uvs\"" ":" NumberList ]
    "," "\"indices\"" ":" NumberList
    "," "\"origin\""  ":" [ Number, Number ]
    [ "," "\"grid_axes\"" ":" GridAxesObject ]
  "}"
  
NumberList      ::= "[" { Number [ "," ] } "]"
OriginObject    ::= "{" "\"x\"" ":" Number "," "\"y\"" ":" Number "}"
GridAxesObject  ::= "[" NumberList "," NumberList "]"
```

- **"verts"**: List of x, y coordinates for each vertex, output as a continuous number list.
- **"uvs"**: (Optional) List of u, v coordinates for each vertex, output as a continuous number list. Omitted if no UV info exists.
- **"indices"**: Index list for vertex connectivity.
- **"origin"**: Object indicating mesh origin.
- **"grid_axes"**: (Optional) For grid meshes, two NumberLists for each axis.

---

### 2.4 Param, Automation, Animations Sections

#### 2.4.1 Param Section

The Param section is output as an array of objects for each parameter.  
Each parameter is output in the following order/structure according to `serializeSelf` implementation.

```
[
  {
    "uuid": String,                // Parameter unique ID
    "name": String,                // Parameter name
    "is_vec2": Boolean,            // Whether the parameter is 2D
    "min": Number | [Number, Number],   // Minimum value (scalar or 2-element array)
    "max": Number | [Number, Number],   // Maximum value (scalar or 2-element array)
    "defaults": Number | [Number, Number], // Default value (scalar or 2-element array)
    "axis_points": [ [Number,...], [Number,...] ],   // Axis point list (1D: [values...], 2D: [ [values...], [values...] ])
    "merge_mode": String,          // Merge mode
    "bindings": [
      {
        ... // Serialized output of each binding (see section 2.5)
      },
      ...
    ]
  },
  ...
]
```

- Each field is always output in the order of the `serializeSelf` call.
- `min`, `max`, `defaults` may be scalars or arrays (vec2).
- `axis_points` is a numerical array; `merge_mode` is a string.
- `bindings` is an array of binding objects, each being the output of `binding.serializeSelf` (see section 2.5).

**Example:**
```
[
  {
    "uuid": "xxxx-xxxx-xxxx-xxxx",
    "name": "ParamA",
    "is_vec2": false,
    "min": 0.0,
    "max": 1.0,
    "defaults": 0.5,
    "axis_points": [[0.0, 0.5, 1.0], [0.0]],
    // For 2D params:
    // "min": [0.0, 0.0],
    // "max": [1.0, 1.0],
    // "defaults": [0.5, 0.5],
    // "axis_points": [[0.0, 0.5, 1.0], [0.0, 1.0]],
    "merge_mode": "replace",
    "bindings": [
      {
        "node": "Node1",
        "param_name": "deform",
        "values": [0.0, 1.0, 0.5],
        "isSet": true
      }
    ]
  }
]
```

#### 2.4.2 Automation Section

```
AutomationSection ::= {
  "param": String,
  "axis" : String,
  "range": [ Number, Number ]
}
```

#### 2.4.3 Animations Section

```
AnimationsSection ::= {
  "timestep" : Number,
  "leadIn"   : Number,
  "leadOut"  : Number,
  "keyframes": [ { "time": Number, "value": Number }, ... ]
  // In implementation, the following additional fields may also be output:
  // "additive": Boolean,           // Whether it is an additive animation
  // "animationWeight": Number,     // Weight in additive animation
  // "length": Number,              // Total frame count
  // "lanes": [ ... ]               // Animation lanes for each parameter/axis
}
```
- Note: Under "lanes" there may be fields such as "interpolation" (interpolation mode), "uuid" (parameter UUID), "target" (axis number), "keyframes" (each keyframe), "merge_mode", etc.  
  Each "keyframes" includes "frame" (frame number), "value" (value), "tension" (interpolation tension).
  These fields are used for detailed control and extensibility of animations.

---

### 2.5 Parameter Binding Specification

#### Basic Syntax

```
Parameter ::= {
  "name"    : String,
  "min"     : Number | [Number, Number],      // Scalar or 2-element array
  "max"     : Number | [Number, Number],      // Scalar or 2-element array
  "default" : Number | [Number, Number],      // Scalar or 2-element array
  "binding" : ParameterBinding
}
```

#### Common Output Items

ParameterBinding always outputs the following items:

```
ParameterBinding ::= {
  "node"            : String,
  "param_name"      : String,
  "values"          : NumberList | [ [Number, ...], ... ], // 1D: [values...], 2D: [ [values...], ... ]
  "isSet"           : Boolean,
  [ "interpolate_mode": String ]
}
```

#### 2.5.1 DeformationParameterBinding  
(Applies to "param_name" = "deform")

```
DeformationParameterBinding ::= ParameterBinding extended by {
  "deformation_strength": Number,
  "deformation_offset"  : Number,
  "deformation_unit"    : String
}
```

#### 2.5.2 ParameterParameterBinding  
(Applies to "param_name" = "X" or "Y" or numeric index 0, 1)

```
ParameterParameterBinding ::= ParameterBinding extended by {
  "target_uuid" : String,
  "target_name" : String
}
```

#### 2.5.3 ValueParameterBinding  
(Applies in other cases)

```
ValueParameterBinding ::= ParameterBinding extended by {
  "value" : Number
}
```

---

## 3. Hierarchical Structure and Serializer Invocation

- **Node Nesting:**  
  Each node recursively serializes its children within `serializeSelfImpl`. Thus, Composite, DynamicComposite, Part, etc. call their respective serializers and are ultimately integrated into the Puppet structure.
- **Integration:**  
  Each main section (meta, physics, nodes, param, automation, animations) is finally integrated into the Puppet object to ensure consistency of the entire output.

---

## 4. Overall Output Format Characteristics

- **Valid JSON:**  
  Each field is strictly defined by a key and its value.
- **Hierarchical Structure:**  
  Nodes form recursive parent-child relationships, allowing the expression of complex object hierarchies.
- **Extensibility:**  
  The implementation of ParameterBinding allows for future specification extensions and addition of deformation info.

---

## 5. Notes on Specification

- Each serializer must strictly follow the invocation rules and consistency between parent and child.
- In ParameterBinding, all common and derived-specific items must be output, and must be reconstructable to the exact type when deserialized.
- Each section must maintain independence, while forming a unified format as a whole.

---
